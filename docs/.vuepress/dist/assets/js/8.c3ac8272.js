(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{207:function(v,_,e){"use strict";e.r(_);var t=e(0),d=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"浏览器渲染的重排与重绘"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染的重排与重绘","aria-hidden":"true"}},[v._v("#")]),v._v(" 浏览器渲染的重排与重绘")]),v._v(" "),e("h2",{attrs:{id:"浏览器渲染html的步骤："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染html的步骤：","aria-hidden":"true"}},[v._v("#")]),v._v(" 浏览器渲染HTML的步骤：")]),v._v(" "),e("p",[v._v("HTML渲染大致分为以下几步：")]),v._v(" "),e("ol",[e("li",[e("code",[v._v("HTML")]),v._v(" 被"),e("code",[v._v("HTML")]),v._v(" 解析器解析成 "),e("code",[v._v("DOM Tree")]),v._v("， "),e("code",[v._v("CSS")]),v._v(" 则被 "),e("code",[v._v("CSS")]),v._v(" 解析器解析成 "),e("code",[v._v("CSSOM Tree")]),v._v("；")]),v._v(" "),e("li",[e("code",[v._v("DOM Tree")]),v._v(" 和 "),e("code",[v._v("CSSOM Tree")]),v._v("解析完成之后，被附加到一起，形成渲染树 （"),e("code",[v._v("Render Tree")]),v._v("）;")]),v._v(" "),e("li",[v._v("节点信息计算（重排），这个过程被叫做 "),e("code",[v._v("Layout")]),v._v(" ( "),e("code",[v._v("Webkit")]),v._v(" )或者 "),e("code",[v._v("Reflow")]),v._v(" ( "),e("code",[v._v("Mozila")]),v._v(" )，即根据渲染树计算每个节点的几何信息；")]),v._v(" "),e("li",[v._v("渲染绘制（重绘），这个过程叫做 "),e("code",[v._v("Painting")]),v._v(" 或者 "),e("code",[v._v("Repaint")]),v._v(" ，即根据计算好的信息绘制整个页面。")])]),v._v(" "),e("p",[v._v("以上4步简述浏览器的一次渲染过程，理论上，每一次的 "),e("code",[v._v("DOM")]),v._v(" 更改或者 "),e("code",[v._v("CSS")]),v._v(" 几何属性更改，都会引起一次浏览器的重排/重绘过程，而如果是 "),e("code",[v._v("CSS")]),v._v(" 的非几何属性更改，则只会引起重绘过程。")]),v._v(" "),e("p",[v._v("所以，"),e("strong",[v._v("重排一定引起重绘，重绘不一定引起重排")]),v._v("。")]),v._v(" "),e("h2",{attrs:{id:"重排（relayout-reflow）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重排（relayout-reflow）","aria-hidden":"true"}},[v._v("#")]),v._v(" 重排（Relayout/Reflow）")]),v._v(" "),e("p",[v._v("首先，浏览器渲染页面默认采用的是流式布局模型。")]),v._v(" "),e("p",[v._v("所谓重排，实际上是根据渲染树中每个渲染对象的信息，计算出各自渲染对象的几何信息（ "),e("code",[v._v("DOM")]),v._v(" 对象的位置和尺寸大小 ），并将其安置在界面的正确位置。")]),v._v(" "),e("p",[v._v("由于浏览器渲染界面是基于流式布局模型的，也就是某一个 "),e("code",[v._v("DOM")]),v._v(" 节点信息更改了，就需要对 "),e("code",[v._v("DOM")]),v._v(" 结构进行重新计算，重新布局界面，再次引发回流，只是这个结构更改程度会决定周边 "),e("code",[v._v("DOM")]),v._v(" 更改范围，即全局范围和局部范围，全局范围就是从根节点 "),e("code",[v._v("html")]),v._v(" 开始对整个渲染树进行重新布局，例如当我们改变了窗口尺寸或者方向，或是修改了根元素的尺寸或字体大小等；而局部布局可以是对渲染树的某部分或某一个对象进行重新布局。")]),v._v(" "),e("p",[v._v("会引起重排的操作有：")]),v._v(" "),e("ul",[e("li",[v._v("页面首次渲染")]),v._v(" "),e("li",[v._v("浏览器窗口发生改变")]),v._v(" "),e("li",[v._v("元素尺寸或位置变化")]),v._v(" "),e("li",[v._v("元素内容、字体大小变化")]),v._v(" "),e("li",[v._v("添加删除可见的 "),e("code",[v._v("DOM")]),v._v(" 元素")]),v._v(" "),e("li",[v._v("激活 "),e("code",[v._v("CSS")]),v._v(" 伪类")]),v._v(" "),e("li",[v._v("设置 "),e("code",[v._v("style")]),v._v(" 属性")]),v._v(" "),e("li",[v._v("查询某些属性或调用方法")])]),v._v(" "),e("table",[e("thead",[e("tr",[e("th",[v._v("常见引起重排属性和方法")]),v._v(" "),e("th"),v._v(" "),e("th")])]),v._v(" "),e("tbody",[e("tr",[e("td",[v._v("width")]),v._v(" "),e("td",[v._v("height")]),v._v(" "),e("td",[v._v("margin")])]),v._v(" "),e("tr",[e("td",[v._v("display")]),v._v(" "),e("td",[v._v("border")]),v._v(" "),e("td",[v._v("position")])]),v._v(" "),e("tr",[e("td",[v._v("clientWidth")]),v._v(" "),e("td",[v._v("clientHeight")]),v._v(" "),e("td",[v._v("clientTop")])]),v._v(" "),e("tr",[e("td",[v._v("offsettWidth")]),v._v(" "),e("td",[v._v("offsetHeight")]),v._v(" "),e("td",[v._v("offsetTop")])]),v._v(" "),e("tr",[e("td",[v._v("scollWidth")]),v._v(" "),e("td",[v._v("scollHeight")]),v._v(" "),e("td",[v._v("scollTop")])]),v._v(" "),e("tr",[e("td",[v._v("scollIntoView()")]),v._v(" "),e("td",[v._v("scollTo()")]),v._v(" "),e("td",[v._v("getComputedStyle()")])]),v._v(" "),e("tr",[e("td",[v._v("getBoundingClientRect()")]),v._v(" "),e("td",[v._v("scollIntoViewIfNeeded()")]),v._v(" "),e("td")])])]),v._v(" "),e("h2",{attrs:{id:"重绘（repainting）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重绘（repainting）","aria-hidden":"true"}},[v._v("#")]),v._v(" 重绘（Repainting）")]),v._v(" "),e("p",[v._v("相比重排，重绘要简单得多，所谓重绘，就是当页面中元素样式的改变并不影响它在文档流中的位置时，例如改变了字体颜色，浏览器会将新样式赋予给元素并重新绘制的过程。")]),v._v(" "),e("table",[e("thead",[e("tr",[e("th",[v._v("常见引起重绘属性")]),v._v(" "),e("th"),v._v(" "),e("th"),v._v(" "),e("th")])]),v._v(" "),e("tbody",[e("tr",[e("td",[v._v("color")]),v._v(" "),e("td",[v._v("border-style")]),v._v(" "),e("td",[v._v("visibility")]),v._v(" "),e("td",[v._v("background")])]),v._v(" "),e("tr",[e("td",[v._v("text-decoration")]),v._v(" "),e("td",[v._v("background-image")]),v._v(" "),e("td",[v._v("background-position")]),v._v(" "),e("td",[v._v("background-repeat")])]),v._v(" "),e("tr",[e("td",[v._v("outline-color")]),v._v(" "),e("td",[v._v("outline")]),v._v(" "),e("td",[v._v("outline-style")]),v._v(" "),e("td",[v._v("border-radius")])]),v._v(" "),e("tr",[e("td",[v._v("outline-width")]),v._v(" "),e("td",[v._v("box-shadow")]),v._v(" "),e("td",[v._v("background-size")]),v._v(" "),e("td")])])]),v._v(" "),e("h2",{attrs:{id:"性能优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#性能优化","aria-hidden":"true"}},[v._v("#")]),v._v(" 性能优化")]),v._v(" "),e("p",[v._v("我们知道操作 "),e("code",[v._v("DOM")]),v._v(" 是一个高成本的操作，不仅是因为本身 "),e("code",[v._v("JS")]),v._v(" 与 "),e("code",[v._v("DOM")]),v._v(" 的链接访问，还包括操作 "),e("code",[v._v("DOM")]),v._v(" 后会引起一连串的连锁反应（重排），因此从性能优化的角度，可以从以下方面入手：")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("减少 "),e("code",[v._v("DOM")]),v._v(" 操作")]),v._v(" "),e("ul",[e("li",[v._v("最小化 "),e("code",[v._v("DOM")]),v._v(" 访问次数，尽量缓存访问 "),e("code",[v._v("DOM")]),v._v(" 的样式信息，避免过度触发回流。")]),v._v(" "),e("li",[v._v("如果在一个局部方法中需要多次访问同一个 "),e("code",[v._v("DOM")]),v._v(" ，则先暂存它的引用。")])])]),v._v(" "),e("li",[e("p",[v._v("采用更优的 "),e("code",[v._v("API")]),v._v(" 替代高消费的 "),e("code",[v._v("API")]),v._v(" ，转换优化消费高的集合")]),v._v(" "),e("ul",[e("li",[v._v("用 "),e("code",[v._v("querySelectorAll()")]),v._v(" 代替 "),e("code",[v._v("getElementByXX()")]),v._v(" ；")]),v._v(" "),e("li",[v._v("开启动画的 "),e("code",[v._v("GPU")]),v._v(" 加速，把渲染计算交给 "),e("code",[v._v("GPU")]),v._v(" ;")]),v._v(" "),e("li",[v._v("少用 "),e("code",[v._v("HTML")]),v._v(" 集合（类数组）来遍历，因为集合遍历比真数组遍历耗费更高；")]),v._v(" "),e("li",[v._v("用事件委托来减少事件处理器的数量。")])])]),v._v(" "),e("li",[e("p",[v._v("减少重排")]),v._v(" "),e("ul",[e("li",[v._v("避免设置大量的 "),e("code",[v._v("style")]),v._v(" 属性，因为设置 "),e("code",[v._v("style")]),v._v(" 属性改变节点样式的话，每一次设置都会触发一次 "),e("code",[v._v("reflow")]),v._v(" ，最好使用 "),e("code",[v._v("class")]),v._v(" 属性；")]),v._v(" "),e("li",[v._v("实现元素动画时最好设置 "),e("code",[v._v("position")]),v._v(" 为 "),e("code",[v._v("fixed")]),v._v(" 或 "),e("code",[v._v("absolute")]),v._v(" ，这样不会影响其他元素布局；")]),v._v(" "),e("li",[v._v("动画实现的速度的选择。比如实现一个动画，以 1 像素为单位移动最平滑，但这样 "),e("code",[v._v("reflow")]),v._v(" 就会过于频繁，大量消耗 "),e("code",[v._v("CPU")]),v._v(" 资源，如果以 3 像素移动则会好很多；")]),v._v(" "),e("li",[v._v("不要使用 "),e("code",[v._v("table")]),v._v(" 布局，因为 "),e("code",[v._v("table")]),v._v(" 中某个元素触发了 "),e("code",[v._v("reflow")]),v._v(" ，那么整个 "),e("code",[v._v("table")]),v._v(" 元素都会触发。在不得已使用 "),e("code",[v._v("table")]),v._v(" 元素的场合，也可以设置 "),e("code",[v._v("table-layout: auto")]),v._v(" 或者 "),e("code",[v._v("table-layout: fixed")]),v._v(" ，这样可以让 "),e("code",[v._v("table")]),v._v(" 一行一行地渲染，限制 "),e("code",[v._v("reflow")]),v._v(" 的影响范围。")])])]),v._v(" "),e("li",[e("p",[e("code",[v._v("css")]),v._v(" 以及动画处理")]),v._v(" "),e("ul",[e("li",[v._v("少用 "),e("code",[v._v("css")]),v._v(" 表达式")]),v._v(" "),e("li",[v._v("减少通过 "),e("code",[v._v("JavaScript")]),v._v(" 代码修改样式，尽量使用修改 "),e("code",[v._v("class")]),v._v(" 名的操作方式；")]),v._v(" "),e("li",[v._v("动画尽量用在绝对定位或固定定位的元素上；")]),v._v(" "),e("li",[v._v("隐藏在屏幕外，或在页面滚动时，尽量停止动画。")])])])])])}),[],!1,null,null,null);_.default=d.exports}}]);