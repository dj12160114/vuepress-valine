# 常用对象和方法

引用类型与基本包装类型的主要区别就是对象的生存期。

使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前一直都保存在内存中。

而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。

```js
var s1 = "some text";
s1.color = "red";
console.log(s1.color); // undefined
```

以上代码中，第二行代码试图为 s1 字符串添加一个 color 属性。但是，当执行第三行代码再次访问 s1 时，其 color 属性不见了。问题的原因是第二行创建的 String 对象在执行到第三行代码时已经被销毁了。第三行代码又创建自己的 String 对象，而该对象没有 color 属性。

## 1. Boolean

typeof 操作符对基本类型返回 boolean，而对引用类型的布尔值返回 object。

其次，引用类型的布尔值是 Boolean 类型的实例，所以 insatanceof 测试 Boolean 会返回 true，而测试基本类型的布尔值会返回 false

```js
var falseObj = new Boolean(false);
var falseVal = false;
console.log(falseObj && true); // true
console.log(falseVal && true); // false

falseObj instanceof Boolean; // true
falseVal instanceof Boolean; // false
```

### 1.1 重写方法

+ `valueOf()`：返回基本类型值 true 或 false

+ `toString()`：返回字符串 “true” 或 “false”

  

## 2. Number

### 2.1 方法

+ `valueOf()` ：返回对象基本类型的数值
+ `toString()`：返回字符串形式的数值
  + 可以为其传递一个表示基数的参数，告诉它返回几进制字符串形式，不传则表示十进制
+ `toLocaleString()`：同上

+ `toFixed()`：接收一个参数为小数位，会按照指定的小数位返回数值的字符串表示

+ `toExponential()`：返回以指数表示法（e表示法）标识的数值的字符串形式
  + 接收一个参数：表示保留小数位

+ `toPrecision()`：可能返回固定大小格式，也可能返回指数格式，具体看哪种更合适
  + 接收一个参数：表示数值的所有数字的位数



## 3.  String

### 3.1 方法

+ `toString()`、`toLocaleString()`、`valueOf()`：返回对象所表示的基本字符串值

**字符方法**

+ `charAt()`：以单字符串的形式返回给定位置的那个字符

  + 访问字符串中的特定字符还可以用方括号加数字索引的方式

+ `charCodeAt()`：返回给定位置的字符的编码

+ `fromCharCode()`：接受一或多个字符编码，将其转换为一个字符串

  ```js
  console.log(String.fromCharCode(104, 101, 108, 108, 111)); // "hello"
  ```

**字符串操作方法**：不修改原字符串🤲

+ `concat()`：接收多个参数，可以通过它拼接任意多个字符串
+ `slice()`
  + 接收1-2个参数：第一个表示开始位置，第二个表示结束位置（可选）
  + 返回：开始位置到结束为止之间的子串，注意不包含结束位置
  + **负值情况**：传入负值就将其与字符串长度相加
  + **前面参数 > 后面参数情况**：返回空字符串
+ `substring()`：同上
  + **负值情况**：将所有负值都转换为0
+ `substr()`：
  + 接收1-2个参数：第一个表示开始位置，第二个**表示返回的字符个数**（）可选。如果没有传入第二个参数，那么就截取到字符串末尾
  + **负值情况**：将负的第一个参数加上字符串长度，负的第二个参数转换为0
  + **前面参数 > 后面参数情况**：将较小的作为起始位置

**字符串位置方法**

+ `indexOf()`
+ `lastIndexOf()`

**大小写转换方法**

+ `toLowerCase()`
+ `toLocaleLowerCase()`
+ `toUpperCase()`
+ `toLocaleUpperCase()`

**字符串模式匹配方法**

+ `match()`
  + 接收一个参数：正则表达式或 RegExp 对象
  + 返回：数组，第一项是与整个模式匹配的字符串，之后的每一项（如果有）保存着与正则表示式中的捕获组匹配的字符串
+ `search()`
  + 接收一个参数：正则表达式或 RegExp 对象
  + 返回：字符串中的一个匹配项的索引，如果没有找到匹配项则返回-1
  + 始终是从开头向后查找模式

+ `replace()`
  + 接收两个参数：第一个是字符串（这个字符串不会被转换正则表达式）或 RegExp 对象；第二个参数是一个字符串或者函数
  + 如果第一个参数是字符串，那么只会替换第一个子字符串，要想替换所有，唯一的办法就是提供一个正则表达式，而且指定全局标志

+ `split()` ：基于指定的分隔将一个字符串分割成多个字符串
  + 接受两个参数：第一个是分隔符，可以是一个字符串也可以是 RegExp 对象，第二个是可选参数，指定数组的大小
  + 返回：数组

**其他**

+ `localeCompare()`：比较两个字符串
  + 接受一个字符串参数
  + 返回：
    + 如果字符串在字母表中应该排在参数之前，返回负数 -1
    + 字符串等于参数，返回 0
    + 字符串在字母表中应该排在参数之后，返回正数 1

+ `trim()`：创建一个字符串副本，删除前置或后缀的所有空格🤲

### 3.2 属性

+ `length` 



## 4. Math

### 4.1 方法

+ `min()`

+ `max()`

+ `Math.ceil()`：向上舍入为最接近的整数

+ `Math.floor()`：向下舍入为最接近的整数

+ `Math.round()`：四舍五入为最接近的整数
  + 参数的小数部分大于0.5，舍入到下一个 **绝对值** 更大的整数
  + 参数的小数部分小于0.5，舍入到下一个 **绝对值** 更小的整数
  + 参数的小数部分等于0.5，舍入到下一个在**正无穷方向**上的整数
  
+ `Math.random()`：返回大于等于0小于1的一个随机数

  

## 5. 数组

- Array 构造函数
  - 传递一个 *数值* 就会创建包含给定项数的数组，非数值则会创建包含这个值的只有一项的数组
  - 可以省略 `new` 操作符
- 数组字面量



### 5.1 检测数组

- `instanceof` 

  - 存在的在浏览器中，我们的脚本可能需要在多个窗口之间进行交互。多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。这可能会引发一些问题。

    比如，表达式 `[] instanceof window.frames[0].Array` 会返回 `false`，因为 `Array.prototype !== window.frames[0].Array.prototype`，并且数组从前者继承。

- `Array.isArray`  

- `Object.prototype.toString.call(myObj) === "[object Array]"`

上面的方法中，后面两种是比较安全的。第一种在多个窗口情况下不准确。



### 5.2 数组方法

**栈或队列方法**：修改原数组🤲

- `pop()`
- `push()`
- `shift()`
- `unshift()`：`IE7` 及更早的版本的 `unshift()` 总是返回 undefined，而不是数组新长度。

**排序方法**：修改原数组🤲

- `reverse()`
- `sort()`：会调用每个数组项的 `toString()` 方法，然后比较得到的字符串，以确定如何排序。
  - 接受一个比较函数作为参数，这个函数接收两个参数，如果第一个参数应该位于第二个的前面，就返回一个负数；如果相等就返回0；如果第一个应该位于第二个后面就返回正数。

**操作方法**：不修改原数组（splice除外）✋

- `concat()`
  - 不传递参数时，返回当前数组的副本；
  - 传递一个或多个数组参数，则将这些 <u>数组的每一项</u> 添加到结果数组中；
  - 传递的值不是数组，就会把这些值简单地添加到数组末尾
- `slice()`：接收一个或两个参数
  - 接收一个参数，返回从参数位置到数组末尾的所有项；
  - 接收两个参数，返回起始位置和结束位置之间的项，**不包括结束位置的项**；
  - 参数中如果有负数，则用数组长度加上该参数来确定相应位置
  - 结束位置小于起始位置，返回空数组
- `splice()`：修改原数组🤲
  - **删除**：接收两个参数：要删除的第一项和删除的个数
  - **插入**：接收三个参数：起始位置，0（删除项数），要插入的项。总之，从第三个参数开始，后面的参数都表示插入项。
  - **替换**：接收三个参数：起始位置，删除项数，要插入的项。
  - 返回值：包含被删除项的数组，没有则为空数组

**位置方法**

- `indexOf()`：从开头查找
  - 接收两个参数：要查找的项，起始位置的索引（可选项）
  - 返回值：找到了就返回查找项在数组中的位置，否则返回-1
  - 比较时采用 `===` 全等操作符
- `lastIndexOf()`：从末尾开始查找，其余同上

**迭代方法**

- `every()`：对数组的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true
- `some()` ：对数组的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true
- `filter()`：对数组的每一项运行给定函数，返回该函数会返回 true 的项组成的数组
- `forEach()`：对数组的每一项运行给定函数，这个方法无返回值
- `map()`: 对每一项运行给定函数，返回每次函数调用的结果组成的数组

**归并方法**

- `reduce()`：从第一项开始逐个遍历到最后
  - 接收两个参数：每一项上调用的函数，作为归并基础的初始值（可选）
  - 第一个参数的函数
    - 接受四个参数：前一个值，当前值，项的索引，数组对象
    - 返回：返回的任何值都会作为 **第一个参数** 自动传给下一项
    - 第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数是数组的第二项
- `reduceRight()`：从数组最后一项开始，向前遍历到第一项
  - 同上

```js
// reduce()举例
var values = [1,2,3,4,5];
var sum = values.reduce(function(prev, cur, index, array) {
    return prev + cur;
});
console.log(sum);
```



## 6.  RegExp

```js
// 字面量
var reg = / pattern / flags; 

// 构造函数形式
var reg = new RegExp('pattern', 'flag');
```

其中的模式（ pattern ）部分可以是任何简单或复杂的正则表达式，每个正则表达式都可带有一或多个标志（ flags ），用以标明正则表达式的行为。

正则表达式的标志有以下 3 个：

- `g` : 全局模式，即模式被应用于所有字符串，而非在发现第一个匹配项时立即停止；

- `i` ：表示不区分大小写模式

- `m`：表示多行模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项

  

### 6.1 实例属性

- `global` ：布尔值，检测是否设置了 g 标志
- `ignoreCase` ：布尔值，标识是否设置了 i 标志
- `multiline` ：布尔值，表示是否设置了 m 标志
- `lastIndex` ：整数，表示开始搜索下一个匹配项的字符位置，从 0 算起
- `source`：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回



### 6.2 实例方法

- `exec()` 
  - 接收一个参数：要应用模式的字符串
  - 返回：包含**第一个匹配项**信息的**数组**，没有匹配项返回 null
    - 数组第一项：是与整个模式匹配的字符串
    - 其他项：是与模式中的捕获组匹配的字符串，没有捕获组，则数组只包含一项
  - 返回的数组虽然是 Array 的实例，但包含两个额外的属性：**index 和 input**
    - **index**：匹配项在字符串中的位置
    - **input**：表示应用正则表达式的字符串
  - 即使在模式中设置了全局标志 g ，每次也只会返回一个匹配项，每次调用 exec() 都会在字符串中继续查找新匹配项；不设置全局标志 g 的情况下，同一个字符串多次调用 exec() 将始终返回第一个匹配项的信息
- `test()`
  - 接收一个参数：字符串
  - 返回：在模式与该参数匹配的情况下返回 true，否则返回 false

