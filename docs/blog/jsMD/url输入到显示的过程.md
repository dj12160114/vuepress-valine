# url输入到显示的过程

简单概括大致流程：

```
- 输入网址
- DNS解析
- 建立 TCP 连接
- 客户端发送 HTTP 请求
- 服务器处理请求
- 服务器响应请求
- 浏览器展示 html
```



## 1. 输入网址

当我们开始在浏览器输入网址，浏览器已经在智能地匹配可能的url了，它会从历史记录、书签等地方，找到已经输入的字符串可能对应的url，然后给出智能提示，让你补全url地址。对于 chrome 浏览器，他还会从缓存中直接把网页展示出来，也就是说还没有按下 enter 键，页面就出来了。

## 2. 浏览器查找域名对应的 IP 地址

域名解析的过程是逐级查询的

+ **浏览器缓存**: 首先会向浏览器的缓存中读取上一次访问的记录，在chrome可以通过地址栏中输入chrome://net-internals/#dns查看缓存的当前状态

+ **操作系统缓存**：查找存储在系统运行内存中的缓存。在mac中可以通过下面的命令清除系统中的DNS缓存。

```
dscacheutil -flushcache
```

+ **在host文件中查找**：如果在缓存中都查找不到的情况下，就会读取系统中预设的host文件中的设置。

+ **路由器缓存**：有些路由器也有DNS缓存的功能，访问过的域名会存在路由器上。

+ **ISP DNS缓存**：互联网服务提供商（如中国电信）也会提供DNS服务，比如比较著名的 114.114.114.114，在本地查找不到的情况下，就会向ISP进行查询，ISP会在当前服务器的缓存内查找是否有记录，如果有，则返回这个IP，若没有，则会开始向根域名服务器请求查询。

+ **顶级DNS服务器/根DNS服务器**：根域名收到请求后，会判别这个域名(.com)是授权给哪台服务器管理,并返回这个顶级DNS服务器的IP。请求者收到这台顶级DNS的服务器IP后，会向该服务器发起查询，如果该服务器无法解析，该服务器就会返回下一级的DNS服务器IP（nicefilm.com），本机继续查找，直到服务器找到(www.nicefilm.com)的主机。



**扩展：**

**1）什么是DNS？**

域名：由一串用点分隔的名字组成的[Internet](https://baike.baidu.com/item/Internet)上某一台[计算机](https://baike.baidu.com/item/计算机/140338)或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）

​	 `DNS`（Domain Name System, 域名系统）因特网上域名和IP地址相互映射的一个分布式数据库，能够使用户更方便地访问互联网，而不是记住机器能读取得IP数串。通过主机名，得到该主机名对应的IP地址的过程，叫做域名解析。

**2）DNS查询的两种方式：递归查询和迭代查询**

+ **递归解析**

当局部DNS服务器不能自己回答客户机的DNS查询时，就需要向其他DNS服务器进行查询。此时有两种方式，如图所示是递归方式。

局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根服务器，再由根域名服务器一级一级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。

![https://img2018.cnblogs.com/blog/1201066/201903/1201066-20190303172106333-747909445.png](https://img2018.cnblogs.com/blog/1201066/201903/1201066-20190303172106333-747909445.png)

+ **迭代解析**

当局部DNS服务器不能自己回答客户机的DNS查询时，也可以采用迭代查询解析。如图所示。

局部DNS服务器不是自己向其他DNS服务器查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再自己向这些DNS服务器查询，直到找到查询结果为止。

也就是说，迭代解析只是帮你找到相关服务器，而不会帮你去查。

![img](https://img2018.cnblogs.com/blog/1201066/201903/1201066-20190303172136423-1666245830.png)

**3）DNS负载均衡**

当一个网站有足够多的用户时，加入每次请求的资源都在同一台机器上，那么这台机器就随时可能会崩掉。处理办法就是用DNS负载均衡技术。

它的原理是在DNS服务器中为**同一个主机名配置多个IP地址**，在应答DNS查询时，DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问引导到不同机器上去，使得不同客户端访问不同服务器，从而达到负载均衡。

## 3.  建立TCP连接

浏览器与服务器通过 TCP三次握手来协商建立 TCP/IP 连接。

+ **第一次握手**：客户端发送 SYN包（seq = x）到服务器，并进入 SYN_SEND 状态，等待服务器确认；
+ **第二次握手**：服务器收到 SYN 包，必须确认客户的 SYN（ack = x+1）,同时自己也发送一个 SYN包（seq = y），即 SYN + ACK包，进入 SYN_RECV 状态；
+ **第三次握手**：客户端收到 SYN + ACK包，向服务器发送确认包 ACK（ack = y+1）,此包发送完毕，客户端和服务器进入 ESTABILISHED 状态，完成三次握手。

握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。

## 4. 浏览器向服务器发送 HTTP请求

建立TCP连接之后，发起一个 http 请求。下面是一个请求信息的样例：

```js
GET/sample.jspHTTP/1.1
Accept:image/gif.image/jpeg,*/*
Accept-Language:zh-cn
Connection:Keep-Alive
Host:localhost
User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)
Accept-Encoding:gzip,deflate

username=admin&password=123456

```

**注意**：最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。

（1）请求的第一行是“方法/ url / 协议版本”：`GET/sample.jspHTTP/1.1`

（2）请求头（Request Header）

请求头包含许多客户端环境和请求正文的有用信息。例如声明浏览器所用的语言、请求正文的长度等。

（3）请求正文

请求头和请求正文之间是一个空行，这个非常重要，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户提交的查询字符串信息：

```js
username=admin&password=123456
```

## 5. 服务器处理请求

后端在固定的端口接收到 TCP 报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装到HTTP request 对象供上层使用。

大一点的网站会将你的请求到反向代理服务其中，因为当网站访问量非常大时，网站越来越慢，一台服务器已经不够用。于是将同一个应用部署到多台服务器上，将大量用户的请求分配到多台机器处理。此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到 `Nginx`，`Nginx`再请求到应用服务器，然后将结果返回给客户端。这里 **`Nginx` 的作用是反向代理服务器**。

通过反向代理，我们到达了web服务器，服务端处理我们的请求，访问数据库，获取内容等。

## 6. 服务器返回一个HTTP响应

经过前面的步骤，服务器会把它的处理结果返回，也就是返回一个HTTP响应，下面是一个HTTP响应的例子：

```html
HTTP/1.1 200 OK     // 状态行
Date: Sat, 31 Dec 2005 23:59:59 GMT
Content-Type: text/html;charset=ISO-8859-1
Content-Length: 122

＜html＞
＜head＞
＜title＞http＜/title＞
＜/head＞
＜body＞
＜!-- body goes here --＞
＜/body＞
＜/html＞
```

+ **状态行**：协议版本/ 状态码/ 状态描述，空格分隔
+ **响应头**：关键字/值对组成，每行一对，关键字和值用英文分隔。
+ **响应正文**：包含我们需要的信息，如 html、image等，注意，响应正文和响应头之间有一行空格，表示响应头信息到空格为止。

## 7. 浏览器显示HTML

浏览器在解析 html 文件时，会自上而下加载，会在加载过程中进行解析渲染。在解析过程中，如果**遇到请求外部资源时，如图片、外链的CSS、iconfront等，请求过程是异步的，并不会影响html文档进行加载**。

**当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。**因为JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。

解析过程中，浏览器首先会解析html文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上，这个过程，比较复杂，设计到两个概念：重排和重绘。



